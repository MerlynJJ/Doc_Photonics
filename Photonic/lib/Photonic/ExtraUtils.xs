
/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */

#define PDL_COMMENT(comment)
PDL_COMMENT("This preprocessor symbol is used to add commentary in the PDL  ")
PDL_COMMENT("autogenerated code. Normally, one would use typical C-style    ")
PDL_COMMENT("multiline comments (i.e. /* comment */). However, because such ")
PDL_COMMENT("comments do not nest, it's not possible for PDL::PP users to   ")
PDL_COMMENT("comment-out sections of code using multiline comments, as is   ")
PDL_COMMENT("often the practice when debugging, for example. So, when you   ")
PDL_COMMENT("see something like this:                                       ")
PDL_COMMENT("                                                               ")
                PDL_COMMENT("Memory access")
PDL_COMMENT("                                                               ")
PDL_COMMENT("just think of it as a C multiline comment like:                ")
PDL_COMMENT("                                                               ")
PDL_COMMENT("   /* Memory access */                                         ")

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; PDL_COMMENT("Structure hold core C functions")
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       PDL_COMMENT("Gets pointer to perl var holding core structure")

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif


	void dgtsl_(int *N, double *c, double *d, double *e, double
		*b, int *info);
	void cgtsl_(int *N, double *c, double *d, double *e, double
		*b, int *info);
typedef struct pdl_dgtsl_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Indx  __inc_c_n;PDL_Indx  __inc_d_n;PDL_Indx  __inc_e_n;PDL_Indx  __inc_y_n;PDL_Indx  __inc_b_n;PDL_Indx  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_dgtsl_struct;

void pdl_dgtsl_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_dgtsl_struct *__privtrans = (pdl_dgtsl_struct *) __tr;
	
	{
	    PDL_Indx __creating[6];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * d_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * d_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * e_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * e_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * info_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * info_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_c_n = __privtrans->__inc_c_n;
register PDL_Indx __inc_d_n = __privtrans->__inc_d_n;
register PDL_Indx __inc_e_n = __privtrans->__inc_e_n;
register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_b_n = __privtrans->__inc_b_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"c","d","e","y","b","info"};
		static PDL_Indx __realdims[] = {1,1,1,1,1,0};
		static char __funcname[] = "Photonic::ExtraUtils::dgtsl";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
if(!__creating[4]) {
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_c_n = 0; else
		 __privtrans->__inc_c_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_d_n = 0; else
		 __privtrans->__inc_d_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_e_n = 0; else
		 __privtrans->__inc_e_n = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_b_n = 0; else
		 __privtrans->__inc_b_n = __privtrans->pdls[4]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_dgtsl_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_dgtsl_struct *__privtrans = (pdl_dgtsl_struct *) __tr;
	
	{
	    pdl_dgtsl_struct *__copy = malloc(sizeof(pdl_dgtsl_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_c_n=__copy->__inc_c_n;__privtrans->__inc_d_n=__copy->__inc_d_n;__privtrans->__inc_e_n=__copy->__inc_e_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_b_n=__copy->__inc_b_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_dgtsl_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_dgtsl_struct *__privtrans = (pdl_dgtsl_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * d_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * d_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * e_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * e_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * info_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * info_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	c_datap += __offsp[0];
	d_datap += __offsp[1];
	e_datap += __offsp[2];
	y_datap += __offsp[3];
	b_datap += __offsp[4];
	info_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,c_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,d_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,e_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,b_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,info_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,c_datap += __tinc0_0
			,d_datap += __tinc0_1
			,e_datap += __tinc0_2
			,y_datap += __tinc0_3
			,b_datap += __tinc0_4
			,info_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_c_n = __privtrans->__inc_c_n;
register PDL_Indx __inc_d_n = __privtrans->__inc_d_n;
register PDL_Indx __inc_e_n = __privtrans->__inc_e_n;
register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_b_n = __privtrans->__inc_b_n;


          int N=__privtrans->__n_size;
	  dgtsl_(&N, c_datap, d_datap, e_datap,b_datap, info_datap);
       
}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	c_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	d_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	e_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	b_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	info_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_dgtsl_free(pdl_trans *__tr ) {
	int __dim;
	pdl_dgtsl_struct *__privtrans = (pdl_dgtsl_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_dgtsl_vtable_flags[] =
	 	{ 0,0,0,0,0,0};
	 pdl_transvtable pdl_dgtsl_vtable = {
		0,0, 4, 6, pdl_dgtsl_vtable_flags,
		pdl_dgtsl_redodims, pdl_dgtsl_readdata, NULL,
		pdl_dgtsl_free,NULL,NULL,pdl_dgtsl_copy,
		sizeof(pdl_dgtsl_struct),"pdl_dgtsl_vtable"
	 };

typedef struct pdl_cgtsl_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Indx  __inc_c_2;PDL_Indx  __inc_c_n;PDL_Indx  __inc_d_2;PDL_Indx  __inc_d_n;PDL_Indx  __inc_e_2;PDL_Indx  __inc_e_n;PDL_Indx  __inc_y_2;PDL_Indx  __inc_y_n;PDL_Indx  __inc_b_2;PDL_Indx  __inc_b_n;PDL_Indx  __n_size;PDL_Indx  __2_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_cgtsl_struct;

void pdl_cgtsl_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_cgtsl_struct *__privtrans = (pdl_cgtsl_struct *) __tr;
	
	{
	    PDL_Indx __creating[6];
__privtrans->__n_size = -1;
__privtrans->__2_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * d_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * d_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * e_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * e_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * info_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * info_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_e_2 = __privtrans->__inc_e_2;
register PDL_Indx __inc_e_n = __privtrans->__inc_e_n;
register PDL_Indx __inc_c_2 = __privtrans->__inc_c_2;
register PDL_Indx __inc_c_n = __privtrans->__inc_c_n;
register PDL_Indx __inc_d_2 = __privtrans->__inc_d_2;
register PDL_Indx __inc_d_n = __privtrans->__inc_d_n;
register PDL_Indx __inc_b_2 = __privtrans->__inc_b_2;
register PDL_Indx __inc_b_n = __privtrans->__inc_b_n;
register PDL_Indx __inc_y_2 = __privtrans->__inc_y_2;
register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"c","d","e","y","b","info"};
		static PDL_Indx __realdims[] = {2,2,2,2,2,0};
		static char __funcname[] = "Photonic::ExtraUtils::cgtsl";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 2) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[3]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[1];
   } else if(((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[1]) {
      if(((__privtrans->pdls[3]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
if(!__creating[4]) {
   if(((__privtrans->pdls[4]))->ndims < 2) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[4]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[4]))->dims[1];
   } else if(((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[4]))->dims[1]) {
      if(((__privtrans->pdls[4]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__2_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_c_2 = 0; else
		 __privtrans->__inc_c_2 = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_c_n = 0; else
		 __privtrans->__inc_c_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_d_2 = 0; else
		 __privtrans->__inc_d_2 = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_d_n = 0; else
		 __privtrans->__inc_d_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_e_2 = 0; else
		 __privtrans->__inc_e_2 = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_e_n = 0; else
		 __privtrans->__inc_e_n = __privtrans->pdls[2]->dimincs[1];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_y_2 = 0; else
		 __privtrans->__inc_y_2 = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 1 || __privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[3]->dimincs[1];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_b_2 = 0; else
		 __privtrans->__inc_b_2 = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 1 || __privtrans->pdls[4]->dims[1] <= 1)
		  __privtrans->__inc_b_n = 0; else
		 __privtrans->__inc_b_n = __privtrans->pdls[4]->dimincs[1]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_cgtsl_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_cgtsl_struct *__privtrans = (pdl_cgtsl_struct *) __tr;
	
	{
	    pdl_cgtsl_struct *__copy = malloc(sizeof(pdl_cgtsl_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_c_2=__copy->__inc_c_2;__privtrans->__inc_c_n=__copy->__inc_c_n;__privtrans->__inc_d_2=__copy->__inc_d_2;__privtrans->__inc_d_n=__copy->__inc_d_n;__privtrans->__inc_e_2=__copy->__inc_e_2;__privtrans->__inc_e_n=__copy->__inc_e_n;__privtrans->__inc_y_2=__copy->__inc_y_2;__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_b_2=__copy->__inc_b_2;__privtrans->__inc_b_n=__copy->__inc_b_n;__copy->__n_size=__privtrans->__n_size;__copy->__2_size=__privtrans->__2_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_cgtsl_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_cgtsl_struct *__privtrans = (pdl_cgtsl_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * d_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * d_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * e_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * e_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * info_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * info_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	c_datap += __offsp[0];
	d_datap += __offsp[1];
	e_datap += __offsp[2];
	y_datap += __offsp[3];
	b_datap += __offsp[4];
	info_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,c_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,d_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,e_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,b_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,info_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,c_datap += __tinc0_0
			,d_datap += __tinc0_1
			,e_datap += __tinc0_2
			,y_datap += __tinc0_3
			,b_datap += __tinc0_4
			,info_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_e_2 = __privtrans->__inc_e_2;
register PDL_Indx __inc_e_n = __privtrans->__inc_e_n;
register PDL_Indx __inc_c_2 = __privtrans->__inc_c_2;
register PDL_Indx __inc_c_n = __privtrans->__inc_c_n;
register PDL_Indx __inc_d_2 = __privtrans->__inc_d_2;
register PDL_Indx __inc_d_n = __privtrans->__inc_d_n;
register PDL_Indx __inc_b_2 = __privtrans->__inc_b_2;
register PDL_Indx __inc_b_n = __privtrans->__inc_b_n;
register PDL_Indx __inc_y_2 = __privtrans->__inc_y_2;
register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;


          int N=__privtrans->__n_size;
	  /* parameter $y is here unneeded */
          cgtsl_(&N, c_datap, d_datap, e_datap,b_datap, info_datap);
       
}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	c_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	d_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	e_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	b_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	info_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_cgtsl_free(pdl_trans *__tr ) {
	int __dim;
	pdl_cgtsl_struct *__privtrans = (pdl_cgtsl_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_cgtsl_vtable_flags[] =
	 	{ 0,0,0,0,0,0};
	 pdl_transvtable pdl_cgtsl_vtable = {
		0,0, 4, 6, pdl_cgtsl_vtable_flags,
		pdl_cgtsl_redodims, pdl_cgtsl_readdata, NULL,
		pdl_cgtsl_free,NULL,NULL,pdl_cgtsl_copy,
		sizeof(pdl_cgtsl_struct),"pdl_cgtsl_vtable"
	 };



MODULE = Photonic::ExtraUtils PACKAGE = Photonic::ExtraUtils

PROTOTYPES: ENABLE

int
set_debugging(i)
	int i;
	CODE:
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
	OUTPUT:
	RETVAL

int
set_boundscheck(i)
       int i;
       CODE:
       if (! 1)
         warn("Bounds checking is disabled for Photonic::ExtraUtils");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
       OUTPUT:
       RETVAL


MODULE = Photonic::ExtraUtils PACKAGE = PDL


void
_dgtsl_int(c,d,e,y,b,info)
	pdl  *c
	pdl  *d
	pdl  *e
	pdl  *y
	pdl  *b
	pdl  *info
 CODE:
 { pdl_dgtsl_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_dgtsl_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((c->state & PDL_BADVAL) > 0) || ((d->state & PDL_BADVAL) > 0) || ((e->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < c->datatype) {
		 	__privtrans->__datatype = c->datatype;
		    }
if(__privtrans->__datatype < d->datatype) {
		 	__privtrans->__datatype = d->datatype;
		    }
if(__privtrans->__datatype < e->datatype) {
		 	__privtrans->__datatype = e->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(!((b->state & PDL_NOMYDIMS) &&
		       b->trans == NULL) && __privtrans->__datatype < b->datatype) {
		 	__privtrans->__datatype = b->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != c->datatype) {
	     c = PDL->get_convertedpdl(c,__privtrans->__datatype);
	  }if(__privtrans->__datatype != d->datatype) {
	     d = PDL->get_convertedpdl(d,__privtrans->__datatype);
	  }if(__privtrans->__datatype != e->datatype) {
	     e = PDL->get_convertedpdl(e,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != b->datatype) {
	     b = PDL->get_convertedpdl(b,__privtrans->__datatype);
	  }if( (info->state & PDL_NOMYDIMS) && info->trans == NULL ) {
	     info->datatype = PDL_L;
	  } else if(PDL_L != info->datatype) {
	     info = PDL->get_convertedpdl(info,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = c;
__privtrans->pdls[1] = d;
__privtrans->pdls[2] = e;
__privtrans->pdls[3] = y;
__privtrans->pdls[4] = b;
__privtrans->pdls[5] = info;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  b->state |= PDL_BADVAL;
  info->state |= PDL_BADVAL;
}
 XSRETURN(0);
}

void
_cgtsl_int(c,d,e,y,b,info)
	pdl  *c
	pdl  *d
	pdl  *e
	pdl  *y
	pdl  *b
	pdl  *info
 CODE:
 { pdl_cgtsl_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_cgtsl_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((c->state & PDL_BADVAL) > 0) || ((d->state & PDL_BADVAL) > 0) || ((e->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < c->datatype) {
		 	__privtrans->__datatype = c->datatype;
		    }
if(__privtrans->__datatype < d->datatype) {
		 	__privtrans->__datatype = d->datatype;
		    }
if(__privtrans->__datatype < e->datatype) {
		 	__privtrans->__datatype = e->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(!((b->state & PDL_NOMYDIMS) &&
		       b->trans == NULL) && __privtrans->__datatype < b->datatype) {
		 	__privtrans->__datatype = b->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != c->datatype) {
	     c = PDL->get_convertedpdl(c,__privtrans->__datatype);
	  }if(__privtrans->__datatype != d->datatype) {
	     d = PDL->get_convertedpdl(d,__privtrans->__datatype);
	  }if(__privtrans->__datatype != e->datatype) {
	     e = PDL->get_convertedpdl(e,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != b->datatype) {
	     b = PDL->get_convertedpdl(b,__privtrans->__datatype);
	  }if( (info->state & PDL_NOMYDIMS) && info->trans == NULL ) {
	     info->datatype = PDL_L;
	  } else if(PDL_L != info->datatype) {
	     info = PDL->get_convertedpdl(info,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = c;
__privtrans->pdls[1] = d;
__privtrans->pdls[2] = e;
__privtrans->pdls[3] = y;
__privtrans->pdls[4] = b;
__privtrans->pdls[5] = info;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  b->state |= PDL_BADVAL;
  info->state |= PDL_BADVAL;
}
 XSRETURN(0);
}


BOOT:

   PDL_COMMENT("Get pointer to structure of core shared C routines")
   PDL_COMMENT("make sure PDL::Core is loaded")
   
   perl_require_pv ("PDL/Core.pm"); /* make sure PDL::Core is loaded */
#ifndef aTHX_
#define aTHX_
#endif
   if (SvTRUE (ERRSV)) Perl_croak(aTHX_ "%s",SvPV_nolen (ERRSV));
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "We require the PDL::Core module, which was not found");
   PDL = INT2PTR(Core*,SvIV( CoreSV ));  /* Core* value */
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "[PDL->Version: %d PDL_CORE_VERSION: %d XS_VERSION: %s] Photonic::ExtraUtils needs to be recompiled against the newly installed PDL", PDL->Version, PDL_CORE_VERSION, XS_VERSION);


     
