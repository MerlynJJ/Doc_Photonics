/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.39 from the
 * contents of ExtraUtils.xs. Do not edit this file, edit ExtraUtils.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "lib/Photonic/ExtraUtils.xs"

/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */

#define PDL_COMMENT(comment)
PDL_COMMENT("This preprocessor symbol is used to add commentary in the PDL  ")
PDL_COMMENT("autogenerated code. Normally, one would use typical C-style    ")
PDL_COMMENT("multiline comments (i.e. /* comment */). However, because such ")
PDL_COMMENT("comments do not nest, it's not possible for PDL::PP users to   ")
PDL_COMMENT("comment-out sections of code using multiline comments, as is   ")
PDL_COMMENT("often the practice when debugging, for example. So, when you   ")
PDL_COMMENT("see something like this:                                       ")
PDL_COMMENT("                                                               ")
                PDL_COMMENT("Memory access")
PDL_COMMENT("                                                               ")
PDL_COMMENT("just think of it as a C multiline comment like:                ")
PDL_COMMENT("                                                               ")
PDL_COMMENT("   /* Memory access */                                         ")

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; PDL_COMMENT("Structure hold core C functions")
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       PDL_COMMENT("Gets pointer to perl var holding core structure")

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif


	void dgtsl_(int *N, double *c, double *d, double *e, double
		*b, int *info);
	void cgtsl_(int *N, double *c, double *d, double *e, double
		*b, int *info);
typedef struct pdl_dgtsl_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Indx  __inc_c_n;PDL_Indx  __inc_d_n;PDL_Indx  __inc_e_n;PDL_Indx  __inc_y_n;PDL_Indx  __inc_b_n;PDL_Indx  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_dgtsl_struct;

void pdl_dgtsl_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_dgtsl_struct *__privtrans = (pdl_dgtsl_struct *) __tr;
	
	{
	    PDL_Indx __creating[6];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * d_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * d_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * e_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * e_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * info_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * info_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_c_n = __privtrans->__inc_c_n;
register PDL_Indx __inc_d_n = __privtrans->__inc_d_n;
register PDL_Indx __inc_e_n = __privtrans->__inc_e_n;
register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_b_n = __privtrans->__inc_b_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"c","d","e","y","b","info"};
		static PDL_Indx __realdims[] = {1,1,1,1,1,0};
		static char __funcname[] = "Photonic::ExtraUtils::dgtsl";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
if(!__creating[4]) {
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in dgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_c_n = 0; else
		 __privtrans->__inc_c_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_d_n = 0; else
		 __privtrans->__inc_d_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_e_n = 0; else
		 __privtrans->__inc_e_n = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_b_n = 0; else
		 __privtrans->__inc_b_n = __privtrans->pdls[4]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_dgtsl_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_dgtsl_struct *__privtrans = (pdl_dgtsl_struct *) __tr;
	
	{
	    pdl_dgtsl_struct *__copy = malloc(sizeof(pdl_dgtsl_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_c_n=__copy->__inc_c_n;__privtrans->__inc_d_n=__copy->__inc_d_n;__privtrans->__inc_e_n=__copy->__inc_e_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_b_n=__copy->__inc_b_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_dgtsl_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_dgtsl_struct *__privtrans = (pdl_dgtsl_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * d_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * d_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * e_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * e_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * info_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * info_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	c_datap += __offsp[0];
	d_datap += __offsp[1];
	e_datap += __offsp[2];
	y_datap += __offsp[3];
	b_datap += __offsp[4];
	info_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,c_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,d_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,e_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,b_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,info_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,c_datap += __tinc0_0
			,d_datap += __tinc0_1
			,e_datap += __tinc0_2
			,y_datap += __tinc0_3
			,b_datap += __tinc0_4
			,info_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_c_n = __privtrans->__inc_c_n;
register PDL_Indx __inc_d_n = __privtrans->__inc_d_n;
register PDL_Indx __inc_e_n = __privtrans->__inc_e_n;
register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_b_n = __privtrans->__inc_b_n;


          int N=__privtrans->__n_size;
	  dgtsl_(&N, c_datap, d_datap, e_datap,b_datap, info_datap);
       
}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	c_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	d_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	e_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	b_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	info_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_dgtsl_free(pdl_trans *__tr ) {
	int __dim;
	pdl_dgtsl_struct *__privtrans = (pdl_dgtsl_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;
			}
			
	}
    }
    



static char pdl_dgtsl_vtable_flags[] =
	 	{ 0,0,0,0,0,0};
	 pdl_transvtable pdl_dgtsl_vtable = {
		0,0, 4, 6, pdl_dgtsl_vtable_flags,
		pdl_dgtsl_redodims, pdl_dgtsl_readdata, NULL,
		pdl_dgtsl_free,NULL,NULL,pdl_dgtsl_copy,
		sizeof(pdl_dgtsl_struct),"pdl_dgtsl_vtable"
	 };

typedef struct pdl_cgtsl_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Indx  __inc_c_2;PDL_Indx  __inc_c_n;PDL_Indx  __inc_d_2;PDL_Indx  __inc_d_n;PDL_Indx  __inc_e_2;PDL_Indx  __inc_e_n;PDL_Indx  __inc_y_2;PDL_Indx  __inc_y_n;PDL_Indx  __inc_b_2;PDL_Indx  __inc_b_n;PDL_Indx  __n_size;PDL_Indx  __2_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_cgtsl_struct;

void pdl_cgtsl_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_cgtsl_struct *__privtrans = (pdl_cgtsl_struct *) __tr;
	
	{
	    PDL_Indx __creating[6];
__privtrans->__n_size = -1;
__privtrans->__2_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * d_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * d_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * e_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * e_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * info_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * info_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_e_2 = __privtrans->__inc_e_2;
register PDL_Indx __inc_e_n = __privtrans->__inc_e_n;
register PDL_Indx __inc_c_2 = __privtrans->__inc_c_2;
register PDL_Indx __inc_c_n = __privtrans->__inc_c_n;
register PDL_Indx __inc_d_2 = __privtrans->__inc_d_2;
register PDL_Indx __inc_d_n = __privtrans->__inc_d_n;
register PDL_Indx __inc_b_2 = __privtrans->__inc_b_2;
register PDL_Indx __inc_b_n = __privtrans->__inc_b_n;
register PDL_Indx __inc_y_2 = __privtrans->__inc_y_2;
register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"c","d","e","y","b","info"};
		static PDL_Indx __realdims[] = {2,2,2,2,2,0};
		static char __funcname[] = "Photonic::ExtraUtils::cgtsl";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 2) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[3]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[1];
   } else if(((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[1]) {
      if(((__privtrans->pdls[3]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
if(!__creating[4]) {
   if(((__privtrans->pdls[4]))->ndims < 2) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[4]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[4]))->dims[1];
   } else if(((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[4]))->dims[1]) {
      if(((__privtrans->pdls[4]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cgtsl:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__2_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_c_2 = 0; else
		 __privtrans->__inc_c_2 = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_c_n = 0; else
		 __privtrans->__inc_c_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_d_2 = 0; else
		 __privtrans->__inc_d_2 = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_d_n = 0; else
		 __privtrans->__inc_d_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_e_2 = 0; else
		 __privtrans->__inc_e_2 = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_e_n = 0; else
		 __privtrans->__inc_e_n = __privtrans->pdls[2]->dimincs[1];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_y_2 = 0; else
		 __privtrans->__inc_y_2 = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 1 || __privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[3]->dimincs[1];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_b_2 = 0; else
		 __privtrans->__inc_b_2 = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 1 || __privtrans->pdls[4]->dims[1] <= 1)
		  __privtrans->__inc_b_n = 0; else
		 __privtrans->__inc_b_n = __privtrans->pdls[4]->dimincs[1]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_cgtsl_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_cgtsl_struct *__privtrans = (pdl_cgtsl_struct *) __tr;
	
	{
	    pdl_cgtsl_struct *__copy = malloc(sizeof(pdl_cgtsl_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_c_2=__copy->__inc_c_2;__privtrans->__inc_c_n=__copy->__inc_c_n;__privtrans->__inc_d_2=__copy->__inc_d_2;__privtrans->__inc_d_n=__copy->__inc_d_n;__privtrans->__inc_e_2=__copy->__inc_e_2;__privtrans->__inc_e_n=__copy->__inc_e_n;__privtrans->__inc_y_2=__copy->__inc_y_2;__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_b_2=__copy->__inc_b_2;__privtrans->__inc_b_n=__copy->__inc_b_n;__copy->__n_size=__privtrans->__n_size;__copy->__2_size=__privtrans->__2_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_cgtsl_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_cgtsl_struct *__privtrans = (pdl_cgtsl_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * d_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * d_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * e_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * e_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * info_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * info_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	c_datap += __offsp[0];
	d_datap += __offsp[1];
	e_datap += __offsp[2];
	y_datap += __offsp[3];
	b_datap += __offsp[4];
	info_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,c_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,d_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,e_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,b_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,info_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,c_datap += __tinc0_0
			,d_datap += __tinc0_1
			,e_datap += __tinc0_2
			,y_datap += __tinc0_3
			,b_datap += __tinc0_4
			,info_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_e_2 = __privtrans->__inc_e_2;
register PDL_Indx __inc_e_n = __privtrans->__inc_e_n;
register PDL_Indx __inc_c_2 = __privtrans->__inc_c_2;
register PDL_Indx __inc_c_n = __privtrans->__inc_c_n;
register PDL_Indx __inc_d_2 = __privtrans->__inc_d_2;
register PDL_Indx __inc_d_n = __privtrans->__inc_d_n;
register PDL_Indx __inc_b_2 = __privtrans->__inc_b_2;
register PDL_Indx __inc_b_n = __privtrans->__inc_b_n;
register PDL_Indx __inc_y_2 = __privtrans->__inc_y_2;
register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;


          int N=__privtrans->__n_size;
	  /* parameter $y is here unneeded */
          cgtsl_(&N, c_datap, d_datap, e_datap,b_datap, info_datap);
       
}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	c_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	d_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	e_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	b_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	info_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_cgtsl_free(pdl_trans *__tr ) {
	int __dim;
	pdl_cgtsl_struct *__privtrans = (pdl_cgtsl_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_cgtsl_vtable_flags[] =
	 	{ 0,0,0,0,0,0};
	 pdl_transvtable pdl_cgtsl_vtable = {
		0,0, 4, 6, pdl_cgtsl_vtable_flags,
		pdl_cgtsl_redodims, pdl_cgtsl_readdata, NULL,
		pdl_cgtsl_free,NULL,NULL,pdl_cgtsl_copy,
		sizeof(pdl_cgtsl_struct),"pdl_cgtsl_vtable"
	 };



#line 928 "lib/Photonic/ExtraUtils.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 1072 "lib/Photonic/ExtraUtils.c"

XS_EUPXS(XS_Photonic__ExtraUtils_set_debugging); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Photonic__ExtraUtils_set_debugging)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 926 "lib/Photonic/ExtraUtils.xs"
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
#line 1088 "lib/Photonic/ExtraUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Photonic__ExtraUtils_set_boundscheck); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Photonic__ExtraUtils_set_boundscheck)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 935 "lib/Photonic/ExtraUtils.xs"
       if (! 1)
         warn("Bounds checking is disabled for Photonic::ExtraUtils");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
#line 1111 "lib/Photonic/ExtraUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PDL__dgtsl_int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__dgtsl_int)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "c, d, e, y, b, info");
    {
	pdl *	c = PDL->SvPDLV(ST(0))
;
	pdl *	d = PDL->SvPDLV(ST(1))
;
	pdl *	e = PDL->SvPDLV(ST(2))
;
	pdl *	y = PDL->SvPDLV(ST(3))
;
	pdl *	b = PDL->SvPDLV(ST(4))
;
	pdl *	info = PDL->SvPDLV(ST(5))
;
#line 955 "lib/Photonic/ExtraUtils.xs"
 { pdl_dgtsl_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_dgtsl_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((c->state & PDL_BADVAL) > 0) || ((d->state & PDL_BADVAL) > 0) || ((e->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < c->datatype) {
		 	__privtrans->__datatype = c->datatype;
		    }
if(__privtrans->__datatype < d->datatype) {
		 	__privtrans->__datatype = d->datatype;
		    }
if(__privtrans->__datatype < e->datatype) {
		 	__privtrans->__datatype = e->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(!((b->state & PDL_NOMYDIMS) &&
		       b->trans == NULL) && __privtrans->__datatype < b->datatype) {
		 	__privtrans->__datatype = b->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != c->datatype) {
	     c = PDL->get_convertedpdl(c,__privtrans->__datatype);
	  }if(__privtrans->__datatype != d->datatype) {
	     d = PDL->get_convertedpdl(d,__privtrans->__datatype);
	  }if(__privtrans->__datatype != e->datatype) {
	     e = PDL->get_convertedpdl(e,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != b->datatype) {
	     b = PDL->get_convertedpdl(b,__privtrans->__datatype);
	  }if( (info->state & PDL_NOMYDIMS) && info->trans == NULL ) {
	     info->datatype = PDL_L;
	  } else if(PDL_L != info->datatype) {
	     info = PDL->get_convertedpdl(info,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = c;
__privtrans->pdls[1] = d;
__privtrans->pdls[2] = e;
__privtrans->pdls[3] = y;
__privtrans->pdls[4] = b;
__privtrans->pdls[5] = info;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  b->state |= PDL_BADVAL;
  info->state |= PDL_BADVAL;
}
 XSRETURN(0);
}
#line 1197 "lib/Photonic/ExtraUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PDL__cgtsl_int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__cgtsl_int)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "c, d, e, y, b, info");
    {
	pdl *	c = PDL->SvPDLV(ST(0))
;
	pdl *	d = PDL->SvPDLV(ST(1))
;
	pdl *	e = PDL->SvPDLV(ST(2))
;
	pdl *	y = PDL->SvPDLV(ST(3))
;
	pdl *	b = PDL->SvPDLV(ST(4))
;
	pdl *	info = PDL->SvPDLV(ST(5))
;
#line 1024 "lib/Photonic/ExtraUtils.xs"
 { pdl_cgtsl_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_cgtsl_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((c->state & PDL_BADVAL) > 0) || ((d->state & PDL_BADVAL) > 0) || ((e->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < c->datatype) {
		 	__privtrans->__datatype = c->datatype;
		    }
if(__privtrans->__datatype < d->datatype) {
		 	__privtrans->__datatype = d->datatype;
		    }
if(__privtrans->__datatype < e->datatype) {
		 	__privtrans->__datatype = e->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(!((b->state & PDL_NOMYDIMS) &&
		       b->trans == NULL) && __privtrans->__datatype < b->datatype) {
		 	__privtrans->__datatype = b->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != c->datatype) {
	     c = PDL->get_convertedpdl(c,__privtrans->__datatype);
	  }if(__privtrans->__datatype != d->datatype) {
	     d = PDL->get_convertedpdl(d,__privtrans->__datatype);
	  }if(__privtrans->__datatype != e->datatype) {
	     e = PDL->get_convertedpdl(e,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != b->datatype) {
	     b = PDL->get_convertedpdl(b,__privtrans->__datatype);
	  }if( (info->state & PDL_NOMYDIMS) && info->trans == NULL ) {
	     info->datatype = PDL_L;
	  } else if(PDL_L != info->datatype) {
	     info = PDL->get_convertedpdl(info,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = c;
__privtrans->pdls[1] = d;
__privtrans->pdls[2] = e;
__privtrans->pdls[3] = y;
__privtrans->pdls[4] = b;
__privtrans->pdls[5] = info;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  b->state |= PDL_BADVAL;
  info->state |= PDL_BADVAL;
}
 XSRETURN(0);
}
#line 1282 "lib/Photonic/ExtraUtils.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Photonic__ExtraUtils); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Photonic__ExtraUtils)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Photonic::ExtraUtils::set_debugging", XS_Photonic__ExtraUtils_set_debugging, file, "$");
        (void)newXSproto_portable("Photonic::ExtraUtils::set_boundscheck", XS_Photonic__ExtraUtils_set_boundscheck, file, "$");
        (void)newXSproto_portable("PDL::_dgtsl_int", XS_PDL__dgtsl_int, file, "$$$$$$");
        (void)newXSproto_portable("PDL::_cgtsl_int", XS_PDL__cgtsl_int, file, "$$$$$$");

    /* Initialisation Section */

#line 1086 "lib/Photonic/ExtraUtils.xs"

   PDL_COMMENT("Get pointer to structure of core shared C routines")
   PDL_COMMENT("make sure PDL::Core is loaded")

   perl_require_pv ("PDL/Core.pm"); /* make sure PDL::Core is loaded */
#ifndef aTHX_
#define aTHX_
#endif
   if (SvTRUE (ERRSV)) Perl_croak(aTHX_ "%s",SvPV_nolen (ERRSV));
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "We require the PDL::Core module, which was not found");
   PDL = INT2PTR(Core*,SvIV( CoreSV ));  /* Core* value */
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "[PDL->Version: %d PDL_CORE_VERSION: %d XS_VERSION: %s] Photonic::ExtraUtils needs to be recompiled against the newly installed PDL", PDL->Version, PDL_CORE_VERSION, XS_VERSION);

#line 1339 "lib/Photonic/ExtraUtils.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

